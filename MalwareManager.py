import socket
import time
import random
import struct
import hashlib
import binascii

class BTCMalwareManager:
    def __init__(self):
       self.inboundAddress = None
       self.inboundPort = None
       self.outboundAddress = None
       self.outboundPort = None
       self.socket = None
       self.magicValue = None
       self.bufferSize = None
       self.version = None

    def return_test_instance(self, inboundAddress, outboundAddress, version):
        self.magicValue =  0x0709110B
        self.inboundAddress = inboundAddress
        self.inboundPort = 18333
        self.outboundAddress = outboundAddress
        self.outboundPort = 18333
        self.bufferSize = 50048
        self.version = version
        self.client = "/Satoshi:0.7.2/"
        self.establishSocketConnection()
        return self

    def create_network_address(self, ip_address, port):
        network_address = struct.pack(">8s16sH", b"\x01",
            str(bytearray.fromhex("00000000000000000000ffff")
            + socket.inet_aton(ip_address)), port)

        return(network_address)

    def create_message(self, command, payload):
        checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[0:4]

        return(struct.pack("L12sL4s", self.magicValue,
            command.encode(), len(payload),
            checksum) + payload)

    def create_sub_version(self):
        return b"\x0F" + self.client.encode()

    # Create the "version" request payload
    def create_payload_version(self):
        services = 1
        timestamp = int(time.time())
        addr_local = self.create_network_address(self.inboundAddress, self.inboundPort)
        addr_peer = self.create_network_address(self.outboundAddress, self.outboundPort)
        nonce = random.getrandbits(64)
        user_agent = '00'
        start_height = 0
        relay_bool = False
        payload = struct.pack("<LQQ26s26sQ0s16sL?",
            self.version, services, timestamp, addr_peer,
            addr_local, nonce, user_agent, self.create_sub_version(), start_height, relay_bool)

        return(payload)

    def create_message_verack(self):
        return bytearray.fromhex("0b110907" + "76657261636b000000000000" + "00000000" + "5df6e0e2")

    def create_payload_getdata(self, tx_id):
        count = 1
        data_type = 1
        hash = bytearray.fromhex(tx_id)
        payload = struct.pack("<bI32p", count, data_type, str(hash))
        return(payload)

    def create_payload_getblocks(self, block_hash, stop_hash):
        block_version = 1
        count = 1
        locator = str(bytearray.fromhex(block_hash))
        stop = str(bytearray.fromhex(stop_hash))
        payload = struct.pack("<Lb32s32s", block_version , count, locator, stop)
        return(payload)

    # def create_payload_filterload(self, hashfunc, )

    def establishSocketConnection(self):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print(self.outboundAddress, self.outboundPort)
        self.socket.connect((self.outboundAddress, self.outboundPort))

    def print_response(self, command, request_data, response_data):
        print("")
        print("Command: " + command)
        print("Request:")
        print(binascii.hexlify(request_data))
        print("Response:")
        print(binascii.hexlify(response_data))
        print("")

    # Initial Handshake Sequence: 1
    def send_version(self):
        version_payload = self.create_payload_version()
        version_message = self.create_message("version", version_payload)

        self.socket.send(version_message)
        # response_data = self.socket.recv(self.bufferSize)
        # self.print_response("version", version_message, response_data)

    # Initial Handshake Sequence: 2
    def send_verack(self):
        verack_message = self.create_message_verack()

        self.socket.send(verack_message)
        # response_data = self.socket.recv(self.bufferSize)
        # self.print_response("version", verack_message, response_data)

    # Attempts to send getdata request to peer, recieves inv object if data matches
    # Note: This only gets 0conf data, or data held in mempool
    def send_getdata(self, tx_id):
        getdata_payload = self.create_payload_getdata(tx_id)
        getdata_message = self.create_message('getdata', getdata_payload)

        self.socket.send(getdata_message)
        response_data = self.socket.recv(self.bufferSize)
        self.print_response("getdata", getdata_message, response_data)

    # Attempts to get block data from block_hash, to hash_stop
    def send_getblocks(self, block_hash, hash_stop):
        getblocks_payload = self.create_payload_getblocks(block_hash, hash_stop)
        getblocks_message = self.create_message('getblocks', getblocks_payload)

        self.socket.send(getblocks_message)
        response_data = self.socket.recv(self.bufferSize)
        self.print_response("getblocks", getblocks_message, response_data)

    def send_getaddr(self):
        getaddr_message = self.create_message('getaddr', '')

        self.socket.send(getaddr_message)
        # response_data = self.socket.recv(self.bufferSize)
        # self.print_response("getaddr", getaddr_message, response_data)

    def recv_data(self, bufferSize):
        response_data = self.socket.recv(bufferSize)

        self.print_response("...", 'incoming', response_data)

    def send_filterload(self, hashfunc):
        return 'n'
    # Handles initial handshake with peer
    def launch(self):
        self.send_version()
        self.send_verack()



# tx_id = "a0ecebde2b7a465604a799b10527003bab9bd3979ed942c0b8ae93f21a4f002e"
# tmp_block_stop = "0000000000000049a7ce260de7fcf63f34acf3fe1c5b2040ae77b9bdaf1abb38"
# tmp_block_hash = "000000000000013d8a77f222805b1dca31d0fb48d60b29098c77609de5f93811"

# block_hash = "".join(list(reversed([tmp_block_hash[i:i+2] for i in range(0, len(tmp_block_hash), 2)])))
# block_stop = "".join(list(reversed([tmp_block_stop[i:i+2] for i in range(0, len(tmp_block_stop), 2)])))

initialConnection = BTCMalwareManager().return_test_instance("127.0.0.7", "127.0.0.1", 70015)
initialConnection.launch()
initialConnection.send_getaddr()
# testnetMalware.send_getdata("b694ee86425764f668b2bde4e77834b4dcc9800fda712e09e0efb8a0e8c67cb8");
# testnetMalware.send_getblocks(block_hash, block_stop)
time.sleep(100)

